// package common

// import (
// 	"encoding/json"
// 	"fmt"
// 	"reflect"
// 	"sort"
// 	"strconv"
// 	"strings"
// 	"sync"
// 	"time"

// 	"github.com/google/uuid"
// )

// type ColInfo struct {
// 	Typ        reflect.Type
// 	TypeName   string
// 	IndexName  string
// 	IsPk       bool
// 	IsUnique   bool
// 	IsNullable bool
// 	DbType     string
// 	Order      int
// 	Name       string
// 	DefaultVal string
// 	Size       int
// 	SubTable   *TableInfo
// }
// type TableInfo struct {
// 	Name           string
// 	Columns        []ColInfo
// 	RelationTables []TableInfo
// 	ForeingKey     []string
// 	ForeingTable   string
// 	EntityType     reflect.Type
// 	Entity         interface{}
// }

// func (t *TableInfo) String() string {
// 	//use unmarshaled json to avoid escape characters indentation
// 	jsonBytes, _ := json.MarshalIndent(t, "", "  ")
// 	return string(jsonBytes)
// }
// func (c *ColInfo) String() string {
// 	//use unmarshaled json to avoid escape characters indentation
// 	jsonBytes, _ := json.MarshalIndent(c, "", "  ")
// 	return string(jsonBytes)
// }

// var tableInfoCache sync.Map

// func GetTableInfoByType(dbType string, typ reflect.Type, onResolveCol func(col *ColInfo) error) (*TableInfo, error) {
// 	key := dbType + ":" + typ.String()
// 	table := TableInfo{
// 		Name:    typ.Name(),
// 		Columns: []ColInfo{},
// 	}
// 	if v, ok := tableInfoCache.Load(key); ok {
// 		return v.(*TableInfo), nil
// 	}
// 	mapCols, err := getTableInfoByType(dbType, typ, onResolveCol)
// 	if err != nil {
// 		return nil, err
// 	}
// 	table.Columns = SortColumns(*mapCols)
// 	tableInfoCache.Store(key, table)
// 	return &table, nil

// }
// func GetTableInfo(dbType string, entity interface{}, onResolveCol func(col *ColInfo) error) (*TableInfo, error) {
// 	typ := reflect.TypeOf(entity)
// 	if typ.Kind() == reflect.Ptr {
// 		typ = typ.Elem()
// 	}
// 	if typ.Kind() != reflect.Struct {
// 		return nil, fmt.Errorf("entity must be a struct or a pointer to a struct, type: %s", typ.String())
// 	}
// 	if typ.Kind() == reflect.Interface {
// 		return nil, nil

// 	}
// 	cols, err := getTableInfoByType(dbType, typ, onResolveCol)
// 	// get related table info
// 	subTables := []TableInfo{}
// 	for _, col := range *cols {
// 		if col.SubTable != nil {
// 			tbl := col.SubTable
// 			tbl.ForeingTable = typ.Name()
// 			subTables = append(subTables, *tbl)
// 		}
// 	}
// 	if err != nil {
// 		return nil, err
// 	}
// 	sortCols := SortColumns(*cols)

// 	ret := &TableInfo{
// 		Name:           typ.Name(),
// 		Columns:        sortCols,
// 		RelationTables: subTables,
// 	}
// 	return ret, nil

// }

// // ==============================
// var dbTypeTagKeWords = map[string][]string{
// 	"size": {"size", "length", "len"},
// 	"text": {"varchar", "text", "string", "char", "cchar"},
// 	"df":   {"default", "default_value"},
// 	"pk":   {"primary_key", "primarykey", "primary_key_index", "primarykey_index", "pk_index", "pkindex", "primary_key_idx", "primarykey_idx", "pkidx"},
// 	"uk":   {"unique", "unique_index", "uniquekey", "unique_key", "uniquekey_index", "unique_key_index", "uk_index", "ukindex", "unique_key_idx", "uniquekey_idx", "ukidx"},
// 	"idx":  {"index", "key", "key_index", "keyindex", "idx_index", "idxindex", "key_idx", "keyidx", "idxidx"},
// }

// func replaceTag(tag string) string {
// 	tag = strings.ToLower(tag)
// 	tag = strings.ReplaceAll(tag, " ", "")
// 	tag = ";" + tag + ";"
// 	for k, v := range dbTypeTagKeWords {
// 		for _, word := range v {
// 			if k != "df" && k != "text" {
// 				tag = strings.ReplaceAll(tag, ";"+word+";", ";"+k+";")
// 				tag = strings.ReplaceAll(tag, ";"+word+":", ";"+k+":")
// 			} else {

// 				tag = strings.ReplaceAll(tag, ";"+word+"(", ";"+k+"(")
// 			}

// 		}
// 	}
// 	return tag
// }
// func getTableInfoByType(dbType string, typ reflect.Type, onResolveCol func(col *ColInfo) error) (*map[string]ColInfo, error) {
// 	ret := make(map[string]ColInfo)
// 	var order = 0
// 	for i := 0; i < typ.NumField(); i++ {
// 		field := typ.Field(i)
// 		ft := field.Type
// 		if ft.Kind() == reflect.Struct {
// 			if ft == reflect.TypeOf(time.Time{}) {
// 				continue
// 			}
// 			if (ft == reflect.TypeOf(uuid.UUID{})) {
// 				continue
// 			}
// 			subCols, err := getTableInfoByType(dbType, ft, onResolveCol)

// 			if err != nil {
// 				return nil, err
// 			}
// 			for _, subCol := range *subCols {

// 				subCol.Order = order
// 				order++
// 				ret[subCol.Name] = subCol
// 			}

// 		}
// 	}
// 	for i := 0; i < typ.NumField(); i++ {
// 		size := -1

// 		field := typ.Field(i)
// 		ft := field.Type
// 		if ft.Kind() == reflect.Interface {
// 			continue
// 		}

// 		if ft.Kind() == reflect.Struct && ft != reflect.TypeOf(time.Time{}) && (ft != reflect.TypeOf(uuid.UUID{})) {
// 			continue

// 		}
// 		if ft.Kind() == reflect.Ptr || ft.Kind() == reflect.Slice {
// 			subType := ft.Elem()
// 			tag := field.Tag.Get("db")
// 			tag = replaceTag(tag)
// 			if strings.Contains(tag, ";fk:") {
// 				if subType.Kind() == reflect.Struct {
// 					subCols, err := getTableInfoByType(dbType, subType, onResolveCol)

// 					if err != nil {
// 						return nil, err
// 					}
// 					foreingKey := strings.Split(tag, ";fk:")[1]
// 					foreingKey = strings.Split(foreingKey, ";")[0]
// 					foreingKeys := strings.Split(foreingKey, ",")

// 					subTable := TableInfo{
// 						Name:       subType.Name(),
// 						Columns:    SortColumns(*subCols),
// 						ForeingKey: foreingKeys,
// 						EntityType: subType,
// 						Entity:     reflect.New(subType).Interface(),
// 					}
// 					ret[field.Name] = ColInfo{
// 						SubTable: &subTable,
// 					}
// 					continue

// 				}
// 			}

// 		}
// 		isNullable := false
// 		if ft.Kind() == reflect.Ptr {
// 			ft = ft.Elem()
// 			isNullable = true
// 		}

// 		tags := replaceTag(field.Tag.Get("db"))
// 		isPk := strings.Contains(tags, ";pk;") || strings.Contains(tags, ";pk:")
// 		isHasIndex := strings.Contains(tags, ";idx;") || strings.Contains(tags, ";idx:")
// 		hasDefault := strings.Contains(tags, ";df(")
// 		hasSize := strings.Contains(tags, ";text(")
// 		if hasSize {
// 			sizeStr := strings.Split(tags, ";text(")[1]
// 			sizeStr = strings.Split(sizeStr, ")")[0]
// 			size, _ = strconv.Atoi(sizeStr)
// 		}
// 		defaultVal := ""
// 		if hasDefault {
// 			defaultVal = strings.Split(tags, ";df(")[1]
// 			defaultVal = strings.Split(defaultVal, ")")[0]
// 		}

// 		isUnique := strings.Contains(tags, ";uk;") ||
// 			strings.Contains(tags, ";uk:")
// 		indexName := ""
// 		if isHasIndex {
// 			if strings.Contains(tags, ";idx:") {
// 				indexName = strings.Split(tags, ";idx:")[1]
// 				indexName = strings.Split(indexName, ";")[0]
// 			} else {
// 				indexName = field.Name + "_idx"
// 			}

// 		}
// 		if isUnique {
// 			if strings.Contains(tags, ";uk:") {
// 				indexName = strings.Split(tags, ";uk:")[1]
// 				indexName = strings.Split(indexName, ";")[0]
// 			} else {
// 				indexName = field.Name + "_uk"
// 			}

// 		}
// 		dbDataType, err := GetDbMapType(dbType, ft)
// 		if err != nil {
// 			return nil, err
// 		}

// 		col := ColInfo{

// 			Typ:        ft,
// 			IndexName:  indexName,
// 			IsUnique:   isUnique,
// 			IsPk:       isPk,
// 			TypeName:   ft.Name(),
// 			Name:       field.Name,
// 			DefaultVal: defaultVal,

// 			IsNullable: isNullable,
// 			DbType:     *dbDataType,
// 			Order:      order,
// 			Size:       size,
// 		}
// 		err = onResolveCol(&col)
// 		if err != nil {
// 			return nil, err
// 		}
// 		order++

// 		ret[field.Name] = col
// 	}
// 	for _, v := range ret {
// 		if v.SubTable != nil {

// 			for k1, _ := range ret {

// 				for i, x := range v.SubTable.ForeingKey {
// 					if x == strings.ToLower(k1) {
// 						v.SubTable.ForeingKey[i] = k1

// 					}
// 				}

// 			}

// 		}
// 	}

// 	return &ret, nil
// }

// var GoTypeToPOSTGRESType = map[reflect.Type]string{
// 	reflect.TypeOf(int(0)):      "integer",
// 	reflect.TypeOf(int8(0)):     "smallint",
// 	reflect.TypeOf(int16(0)):    "smallint",
// 	reflect.TypeOf(int32(0)):    "integer",
// 	reflect.TypeOf(int64(0)):    "bigint",
// 	reflect.TypeOf(uint(0)):     "integer",
// 	reflect.TypeOf(uint8(0)):    "smallint",
// 	reflect.TypeOf(uint16(0)):   "smallint",
// 	reflect.TypeOf(uint32(0)):   "integer",
// 	reflect.TypeOf(uint64(0)):   "bigint",
// 	reflect.TypeOf(float32(0)):  "real",
// 	reflect.TypeOf(float64(0)):  "double precision",
// 	reflect.TypeOf(bool(false)): "boolean",
// 	reflect.TypeOf(string("")):  "citext",
// 	reflect.TypeOf(time.Time{}): "timestamp with time zone",
// 	reflect.TypeOf(uuid.UUID{}): "uuid",
// }
// var GoTypeToMySQLType = map[reflect.Type]string{
// 	reflect.TypeOf(int(0)):      "int",
// 	reflect.TypeOf(int8(0)):     "tinyint",
// 	reflect.TypeOf(int16(0)):    "smallint",
// 	reflect.TypeOf(int32(0)):    "int",
// 	reflect.TypeOf(int64(0)):    "bigint",
// 	reflect.TypeOf(uint(0)):     "int",
// 	reflect.TypeOf(uint8(0)):    "tinyint",
// 	reflect.TypeOf(uint16(0)):   "smallint",
// 	reflect.TypeOf(uint32(0)):   "int",
// 	reflect.TypeOf(uint64(0)):   "bigint",
// 	reflect.TypeOf(float32(0)):  "float",
// 	reflect.TypeOf(float64(0)):  "double",
// 	reflect.TypeOf(bool(false)): "boolean",
// 	reflect.TypeOf(string("")):  "varchar",
// 	reflect.TypeOf(time.Time{}): "datetime",
// 	reflect.TypeOf(uuid.UUID{}): "char(36)",
// }
// var GoTypeToMssqlType = map[reflect.Type]string{
// 	reflect.TypeOf(int(0)):      "int",
// 	reflect.TypeOf(int8(0)):     "tinyint",
// 	reflect.TypeOf(int16(0)):    "smallint",
// 	reflect.TypeOf(int32(0)):    "int",
// 	reflect.TypeOf(int64(0)):    "bigint",
// 	reflect.TypeOf(uint(0)):     "int",
// 	reflect.TypeOf(uint8(0)):    "tinyint",
// 	reflect.TypeOf(uint16(0)):   "smallint",
// 	reflect.TypeOf(uint32(0)):   "int",
// 	reflect.TypeOf(uint64(0)):   "bigint",
// 	reflect.TypeOf(float32(0)):  "float",
// 	reflect.TypeOf(float64(0)):  "float",
// 	reflect.TypeOf(bool(false)): "bit",
// 	reflect.TypeOf(string("")):  "nvarchar",
// 	reflect.TypeOf(time.Time{}): "datetime2",
// 	reflect.TypeOf(uuid.UUID{}): "uniqueidentifier",
// }
// var DbMapTypes = map[string]map[reflect.Type]string{
// 	"postgres": GoTypeToPOSTGRESType,
// 	"mysql":    GoTypeToMySQLType,
// 	"mssql":    GoTypeToMssqlType,
// }

// func GetDbMapType(dbType string, typ reflect.Type) (*string, error) {
// 	if _, ok := DbMapTypes[dbType][typ]; !ok {
// 		fmt.Print(typ.String())
// 		return nil, fmt.Errorf("%s %s not support", dbType, typ.String())
// 	}
// 	if _, ok := DbMapTypes[dbType][typ]; !ok {
// 		// fmt.Print(typ.String())
// 		return nil, fmt.Errorf("%s %s not support", dbType, typ.String())
// 	}
// 	ret := DbMapTypes[dbType][typ]
// 	return &ret, nil
// }
// func SortColumns(cols map[string]ColInfo) []ColInfo {
// 	var ret []ColInfo
// 	for _, col := range cols {
// 		if col.Name == "" {
// 			continue
// 		}

// 		ret = append(ret, col)
// 	}
// 	sort.Slice(ret, func(i, j int) bool {
// 		return ret[i].Order < ret[j].Order
// 	})
// 	return ret
// }
// func GetAllIndexInColsInfo(colsInfo []ColInfo) map[string][]ColInfo {
// 	var indexMap = make(map[string][]ColInfo)
// 	for _, colInfo := range colsInfo {

// 		if colInfo.IsPk {
// 			// if _, ok := indexMap[colInfo.IndexName]; !ok {
// 			// 	indexMap[colInfo.IndexName] = []ColInfo{colInfo}
// 			// 	continue
// 			// } else {
// 			// 	indexMap[colInfo.IndexName] = append(indexMap[colInfo.IndexName], colInfo)
// 			// 	continue
// 			// }
// 			continue

// 		}
// 		if colInfo.IsUnique {
// 			if _, ok := indexMap[colInfo.IndexName]; !ok {
// 				indexMap[colInfo.IndexName] = []ColInfo{colInfo}
// 				continue
// 			} else {
// 				indexMap[colInfo.IndexName] = append(indexMap[colInfo.IndexName], colInfo)
// 				continue

// 			}

// 		}
// 		if colInfo.IndexName != "" {
// 			if _, ok := indexMap[colInfo.IndexName]; !ok {
// 				indexMap[colInfo.IndexName] = []ColInfo{colInfo}
// 				continue
// 			} else {
// 				cols := indexMap[colInfo.IndexName]
// 				indexMap[colInfo.IndexName] = append(cols, colInfo)
// 				continue
// 			}

// 		}
// 	}
// 	return indexMap
// }
